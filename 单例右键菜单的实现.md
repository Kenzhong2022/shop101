# 单例右键菜单的实现原理

## 核心逻辑的技术拆解

### 1. 获取 isShow 的 ref 并暂存到全局变量

每个 `useContextMenu` 调用都会创建独立的 `isShow` ref 对象（ref 是引用类型，每个实例的 isShow 指向不同内存地址）。

全局变量 `lastActiveMenu` 的作用就是缓存"上一个激活菜单实例的 isShow ref 对象"——本质是保存这个 ref 的引用地址，而非值。

```javascript
// 每个实例创建时
const isShow = ref(false); // 独立的 ref 对象
// lastActiveMenu 保存的是这个 ref 的引用
lastActiveMenu = isShow;   // 保存引用地址，而非值
```

### 2. 新实例创建前，判断全局变量是否被赋值

当触发新菜单的 `showMenu` 时（不是"新实例创建前"，而是"新菜单显示前"），先执行 `turnOffLastActiveMenu`。

函数内判断 `lastActiveMenu?.value`：
- 若 `lastActiveMenu` 有值（说明存在上一个激活的菜单），则修改其 `value`
- 若 `lastActiveMenu` 为 null（无激活菜单），则无操作

```javascript
function turnOffLastActiveMenu() {
  if (lastActiveMenu?.value) {
    lastActiveMenu.value = false; // 直接修改上一个实例的 isShow
  }
}
```

### 3. 调整全局变量的 ref 的 value，利用引用 + 响应式关闭上一个菜单

这是最关键的一步，核心是 ref 的"引用特性"+"响应式特性"：

**引用特性**：`lastActiveMenu` 保存的是上一个实例的 `isShow` ref 对象的引用（地址），修改 `lastActiveMenu.value` 等同于直接修改上一个实例的 `isShow.value`。

**响应式特性**：`isShow.value` 是响应式的，当它被改为 `false` 时，绑定该状态的菜单 DOM（`v-show="isShow"`）会立即更新，表现为"菜单隐藏"。

## 可视化理解（内存地址模拟）

假设存在两个菜单实例，我们用「内存地址」模拟这个过程：

```javascript
// 实例1创建：生成独立的isShow ref
const isShow1 = ref(false); // 内存地址：0x001
lastActiveMenu = isShow1;   // 全局变量指向0x001

// 实例1激活：isShow1.value = true → 菜单1显示
isShow1.value = true; // 0x001的value变为true

// 实例2激活：先执行关闭逻辑
const isShow2 = ref(false);   // 内存地址：0x002
// 检查lastActiveMenu（指向0x001），修改其value
lastActiveMenu.value = false; // 0x001的value变为false → 菜单1关闭
// 把全局变量指向新实例的isShow
lastActiveMenu = isShow2;     // 全局变量指向0x002
isShow2.value = true;         // 0x002的value变为true → 菜单2显示
```

## 关键细节说明

### 1. 时机问题：不是"新实例创建前"，而是"新菜单显示前"

实例创建（调用 `useContextMenu`）时只是初始化 `isShow`，并不会触发关闭逻辑；只有当右键点击触发 `showMenu`（菜单要显示）时，才会先关闭上一个菜单。

### 2. 引用类型 vs 值类型

全局变量保存的是"ref 对象"，而非"value 值"。

如果全局变量只保存 `isShow.value`（布尔值），则无法反向修改原实例的状态（因为布尔值是值类型，赋值后是独立副本）；正因为保存的是 ref 对象（引用类型），才能跨实例修改状态。

```javascript
// ❌ 错误：保存值，无法跨实例修改
lastActiveMenu = isShow.value; // 只是保存了布尔值

// ✅ 正确：保存引用，可以跨实例修改
lastActiveMenu = isShow; // 保存了 ref 对象的引用
```

## 完整代码实现

```javascript
import { ref, onMounted, onUnmounted } from "vue";

/* ---------- 单例核心 ---------- */
let lastActiveMenu = null; // 存储上一次激活的菜单实例（isShow ref）

/**
 * 关闭上一次激活的菜单
 * 核心：lastActiveMenu 存储了上一个激活的菜单isShow状态，直接修改其value为false即可关闭
 */
function turnOffLastActiveMenu() {
  if (lastActiveMenu?.value) {
    lastActiveMenu.value = false; // 直接修改上一个实例的isShow为false，实现关闭
  }
}
/* -------------------------------- */

/**
 * 右键菜单hooks（支持单例/多例模式）
 * @param {Ref} contextMenuRef 菜单DOM引用
 * @param {boolean} multi 是否多例（默认false：单例，同一时间仅显示一个）
 * @returns {Object} 菜单状态和方法
 */
export function useContextMenu(contextMenuRef, multi = false) {
  // 生成唯一标识，方便区分不同实例（核心：每个实例的isShow是独立的ref）
  const instanceId = Math.random().toString(36).slice(2, 8);
  const isShow = ref(false);
  const x = ref(0);
  const y = ref(0);

  const showMenu = (e) => {
    e.preventDefault();
    e.stopPropagation();

    if (!multi) {
      turnOffLastActiveMenu(); // 单例模式：显示当前菜单前，先关闭上一个激活的
    }

    isShow.value = true;

    if (!multi) {
      lastActiveMenu = isShow; // 把当前实例的isShow存入全局，作为"上一个激活标记"
    }

    x.value = e.clientX;
    y.value = e.clientY;
  };

  const hideMenu = () => {
    isShow.value = false;
  };

  onMounted(() => {
    const el = contextMenuRef.value;
    if (el) el.addEventListener("contextmenu", showMenu);
    
    // 绑定全局隐藏事件（点击/右键/滚动时关闭当前菜单）
    window.addEventListener("click", hideMenu);
    window.addEventListener("contextmenu", hideMenu);
    window.addEventListener("scroll", hideMenu);
  });

  onUnmounted(() => {
    const el = contextMenuRef.value;
    if (el) el.removeEventListener("contextmenu", showMenu);
    
    // 移除全局隐藏事件
    window.removeEventListener("click", hideMenu);
    window.removeEventListener("contextmenu", hideMenu);
    window.removeEventListener("scroll", hideMenu);

    // 单例模式下：如果当前实例是"上一个激活的菜单"，释放全局标记
    if (!multi && lastActiveMenu === isShow) {
      lastActiveMenu = null;
    }
  });

  return { isShow, x, y, hideMenu, instanceId };
}
```

## 总结

这个实现精准命中了核心：**利用全局变量缓存上一个菜单的 isShow ref 引用，通过修改 ref 的响应式 value，实现跨实例关闭上一个菜单**。

这也是 Vue 中"跨组件/跨实例共享并修改响应式状态"的经典思路（类似简易版 Pinia/Vuex，只是用全局变量实现极简版状态共享）。

关键点：
1. **引用类型**：保存的是 ref 对象的引用，而非值
2. **响应式**：修改 ref.value 会触发视图更新
3. **单例控制**：通过全局变量实现跨实例的状态管理
4. **生命周期**：在组件卸载时清理全局引用，避免内存泄漏